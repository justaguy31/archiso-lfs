#! /bin/bash
# lfs-install - initialization plus formatting the internal storage
# Copyright (C) 2023 Beloglazov Mark <justaguy3331@gmail.com>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>.
set -e
# Color codes for texts
success="\e[0;96m" # High intensity cyan
warning="\e[0;93m" # High intensity yellow
error="\e[0;91m"   # High intensity red
info="\e[0;97m"    # High intensity white
default="\e[0m"    # White unless you modify the default shell color

# Read the arguments for lfs-install
args=$(getopt -a --options d:fhks:l --long "debug:,full-save,help,keep-going,save-file:,license" -- "$@")
if [ $? -ne 0 ]; then
  echo "Use '-h' or '--help' for usage."
  exit 1
fi
eval set -- "$args"

while true; do
  case "$1" in
# -d <var> --debug <var>
# a - print everything
# b - only print current stage of installation
# v - print which scripts and Makefile recipes were invoked and when they exited
# j - print which sub-commands were invoked and when they exited
# p - print which directories were invoked
# n - print no debugging information
  -d|--debug)
    opt_debug="$2"
    shift 2;;
# -f --full-save
  -f|--full-save)
    opt_full_save="1"
    shift 1;;

# -h --help
  -h|--help)
    echo "Usage:"
    echo " lfs-install [-d <opt_debug>] [-h] [-i] [-k] [-s <filename>] [-l]"
    echo ""
    echo "Install Linux From Scratch to a desired drive."
    echo ""
    echo "Options:"
    echo " -d, --debug <opt_debug>    filter debug messages by a desired level"
    echo " -f, --full-save            store all save variables in a savefile"
    echo " -h, --help                 display this help and exit"
    echo " -k, --keep-going           keep going if any error happens, very dangerous option"
    echo " -s, --save-file <filename> define a filename or path to save file, or start with a new save file"
    echo " -l, --license              show script license"
    echo ""
    echo "The 'opt_debug' argument can be 'a' (all), 'b' (currently active stage, see save variables for names),"
    echo "'j' (print which sub-commands are currently invoked),"
    echo "'p' (print which directory is currently invoked),"
    echo "'n' (print no debugging information)."
    echo ""
    echo "The 'filename' argument can be a path to existing savefile, or a path to a new one."
    echo "lfs-install will prompt user for creating new file (recursively) if it doesn't exist"
    echo "while also informing of nonexistent directories."
    exit 0;;

# -k --keep-going
  -k|--keep-going)
    set +e
    shift 1;;

# -s <var> --save-file <var>
# Note that this works only if your internal storage is complete.
# If not, the script will store the var and wait.
  -s|--save-file)
    opt_save_file="$2"
    shift 2;;

# -l --license
  -l|--license)
    echo -e "${info}Please note that you can always exit by pressing 'q'.${default}"
    read -p "Press enter to continue."
    less /usr/local/share/doc/lfs-install/LICENSE
    exit 0;;
  --)
    break;;
  esac
done

echo "run.sh Copyright (C) 2023 Beloglazov Mark <justaguy3331@gmail.com>

This program comes with ABSOLUTELY NO WARRANTY;
for details use '-l' or '--license' options.
This is free software, and you are welcome to redistribute it
under certain conditions; use '-l' or '--license' options for details.
"

# Simple error function to reduce code size
error() {
  echo -e "${error}Error:" $1
  exit 1
}

# Error that is related to a corrupted save file
save-error() {
  echo -e "${error}Error: this save file is corrupted"
  echo -e "(\$$1 is equal to neither 1 or 0).${default}"
  echo -e "${info}You might want to edit the save file using 'nano'"
  echo -e "(the full location of the save file is $opt_save_file)."
  echo -e "Please note that "1" means the stage is done, and "0" means the stage is not done.${default}"
  exit 1
}

# Load save file if it exists
if [ -f $opt_save_file ]; then
  source $opt_save_file
  fullsavename=$opt_save_file
  mount ${savedevice}2 $savelocation        || true
  mount ${savedevice}3 ${savelocation}/boot || true
else
  if [[ ! -z $opt_save_file ]]; then
    echo -e "${warning}Save file not found, storing the path to possibly create it later.${default}"
  fi
fi

# Check whether the script is being run with sudo privileges
sudocheck=$(whoami)
if [[ -z "$sudocheck" ]]; then
  error "The result of `whoami` is empty. Perhaps your are running in chroot?${default}"
fi
case $sudocheck in
  root)
    echo -e"${success}Running as sudo (root).${default}"
  ;;
  *)
    error "You must be running this script with sudo (root) privileges.${default}"
  ;;
esac

# Partitioning stage
if [[ -z "$save_partitions" ]]; then
  save_partitions=0
fi
case $save_partitions in
  1)
  ;;
  0)
    echo "Choose a device to format:"
    lsblk -d
    choose-device() {
      read -p "Enter in the name of the device you've chosen:" devdisk
      if [[ -z "`lsblk -d | grep $devdisk`" || -z "$devdisk" ]]; then
        echo -e "${warning}Please enter a valid device name.${default}"
        choose-device
      fi
    }
    choose-device
    # Defining variables for the next actions
    # 'export' just in case, see line 339 (out of this 'case' scope)
    export parteddevice="/dev/$devdisk"
    if [[ ! -z "`mount | grep $parteddevice`"]]; then
      echo -e "${warning}Warning: this device has one or more mountpoints.${default}"
      umountbusydevice-func() {
        read -p "Would you like to unmount all the partitions of the device? (Y/n)" umountbusydevice
        if [[ -z "$umountbusydevice" ]]; then
          umountbusydevice=y
        fi
        case $umountbusydevice in
          [Yy])
            umount ${parteddevice}?*
          ;;
          [Nn])
            exit 1
          ;;
          *)
            umountbusydevice-func
        esac
      }
      umountbusydevice-func
    fi
    partedsize=`parted --script $parteddevice unit MiB print | grep Disk | awk '{print $3}'`
    partedsize=${partedsize::-3}
    partedlfs=`echo "scale=100; $partedsize - 500" | bc -l`
    # Partitioning the internal storage
    # https://wiki.archlinux.org/title/Partitioning
    if [ -d /sys/firmware/efi ]; then
      echo -e "${info}It appears that your machine has UEFI."
      echo    "It is usually used with GPT partition table, however,"
      echo    "there is an older firmware called BIOS, which instead supports only MBR."
      echo    "UEFI can use that partition table for backwards compatibility,"
      echo -e "but this is recommended to pick only if you need support for BIOS machines.${default}"
      partitiontable-func() {
        read -p "Would you like to use MBR partition table? (y/N)" partitiontable
        if [[ -z "$partitiontable" ]]; then
          partitiontable=n
        fi
        case $partitiontable in
          [Yy])
            parted --script $parteddevice mktable mbr
          ;;
          [Nn])
            echo -e "${info}Using GPT partition table.${default}"
            parted --script $parteddevice mktable gpt
          ;;
          *)
            partitiontable-func
        esac
      }
      partitiontable-func
    fi
    parted --script $parteddevice mkpart lfs-swap linux-swap 1MiB 512MiB
    parted --script $parteddevice mkpart lfs ext4 512MiB ${partedlfs}MiB
    parted --script $parteddevice mkpart lfs-efi  fat32  ${partedlfs}MiB 100%
    # Formatting the partitions
    # https://wiki.archlinux.org/title/Installation_guide#Format_the_partitions
    mkswap    --verbose ${parteddevice}1
    mkfs.ext4 -v        ${parteddevice}2
    mkfs.fat  -v -F 32  ${parteddevice}3
    if [ ! -z $opt_save_file ]; then
      if [ -f $opt_save_file ]; then
        echo "save_partitions=1" >> $opt_save_file
      fi
    fi
    save_partitions=1
  ;;
  *)
    save-error "save_partitions"
esac

# Save creation stage
if [[ -z "$save_created" ]]; then
  save_created=0
fi
# For improving readability
choose-directory() {
  echo    "Choose a directory to mount $parteddevice to."
  echo -e "${info}Note: if you pick a directory with contents,"
  read -p "'umount ${parteddevice}2' to access them after exiting the script! (/mnt by default):" savelocation
  if [[ -z "$savelocation" ]]; then
    savelocation=/mnt
  fi
}
save-argument() {
# I regret having to write something that big in an if statement
  if [ ! -f $opt_save_file ]; then
    savelocation=`dirname  $opt_save_file`
    savefilename=`basename $opt_save_file`
    if [[ ! -d "$savelocation" ]]; then
      save-argument-invalid() {
        echo -e "${warning}The path you passed in argument does not exist.${default}"
        read -p "Would you like to create it? [yes, no, retry] (y/n/R):" createpath
        if [[ -z "$createpath" ]]; then
          choose-directory
          save-argument
        fi
        case $createpath in
          [Yy])
            mkdir -pv $savelocation
          ;;
          [Nn])
            exitorcontinue-func() {
              read -p "Would you like to exit now or continue running (the script will start over upon next run!) (Y/n)?" exitorcontinue
              if [[ -z "$exitorcontinue" ]]; then
                exit 1
              fi
              case $exitorcontinue in
                [Yy])
                  exit 1
                ;;
                [Nn])
                  echo "Continue running..."
                ;;
                *)
                  exitorcontinue-func
              esac
            }
            exitorcontinue-func
          ;;
          [Rr])
            choose-directory
            directory-arg-invalid
          ;;
          *)
            save-argument-invalid
        esac
      }
      save-argument-invalid
    fi
    fullsavename=${savelocation}/${savefilename}.sh
    touch $fullsavename
    echo "savedevice=$parteddevice\nsavelocation=$savelocation\nsave_partitions=1\nsave_created=1\n" > $fullsavename
    awk -i inplace '!seen[$0]++' $fullsavename
    sed -i /save_partitions=0/d  $fullsavename
    sed -i /save_created=0/d     $fullsavename
    save_created=1
  fi
}
save-argument

case $save_created in
  1)
  ;;
  0)
    choose-directory
    path-check() {
      if [[ ! -d "$savelocation" ]]; then
        save-path-invalid() {
          echo -e "${warning}The path you entered in does not exist.${default}"
          read -p "Would you like to create it? [yes, no, retry] (y/n/R):" createpath
          if [[ -z "$createpath" ]]; then
            choose-directory
            path-check
          fi
          case $createpath in
            [Yy])
              mkdir $savelocation
            ;;
            [Nn])
              exitorcontinue-func() {
                read -p "Would you like to exit now or continue running (the script will start over upon next run!) (Y/n)?" exitorcontinue
                if [[ -z "$exitorcontinue" ]]; then
                  exit 1
                fi
                case $exitorcontinue in
                  [Yy])
                    exit 1
                  ;;
                  [Nn])
                    echo "Continue running..."
                  ;;
                  *)
                    exitorcontinue-func
                esac
              }
              exitorcontinue-func
            ;;
            [Rr])
              choose-directory
              path-check
            ;;
            *)
            save-path-invalid
          esac
        }
        save-path-invalid
      fi
    }
    path-check
    mount ${parteddevice}2 $savelocation
    read  -p "Pick a name for the save file ('lfs-save' by default):" savefilename
    if [[ -z "$savefilename" ]]; then
      savefilename=lfs-save
    fi
    if [[ -z "$fullsavename" ]]; then
      fullsavename=${savelocation}/${savefilename}.sh
    fi
    if [ ! -f $fullsavename ]; then
      touch $fullsavename
    fi
    # Saving the progress in the save file
    echo -e "savedevice=$parteddevice\nsavelocation=$savelocation\nsave_partitions=1\nsave_created=1\n" > $fullsavename # write certain variables to save file
    awk  -i inplace '!seen[$0]++' $fullsavename # remove duplicates of lines
    sed  -i /save_partitions=0/d  $fullsavename # remove "save_partitions=0" line if present
    sed  -i /save_created=0/d     $fullsavename # remove "save_created=0" line if present
    echo -e "${success}Save file successfully created.${default}"
  ;;
  *)
    save-error "save_created"
esac

# Preparing the system stage
case $save_build_preparation in
  1)
  ;;
  0)
    # Chapter 3
    mkdir -pv ${savelocation}/sources
    # Chapter 4
    mkdir -pv ${savelocation}/{etc,var} ${savelocation}/usr/{bin,lib,sbin}
    for i in bin lib sbin; do
      ln -sv usr/$i ${savelocation}/$i
    done
    case $(uname -m) in
      x86_64)
        mkdir -pv ${savelocation}/lib64
      ;;
    esac
    mkdir -pv ${savelocation}/tools
    
    echo -e "save_build_preparation=1\n" > $fullsavename
    awk  -i inplace '!seen[$0]++'          $fullsavename
    sed  -i /save_build_preparation=0/d    $fullsavename
    echo -e "${success}System successfully prepared.${default}"
  ;;
  *)
    save-error "save_build_preparation"
esac

# Installing cross binutils stage
case $save_cross_binutils in
  1)
  ;;
  0)
    binutils_dir=${savelocation}/sources/binutils
    mkdir -pv $binutils_dir
    curl --verbose https://ftp.gnu.org/gnu/binutils/binutils-2.42.tar.xz --output ${binutils_dir}/binutils-2.42.tar.xz
    checksum=`sha512sum binutils-2.42.tar.xz`
    if [ $checksum -ne `echo /etc/lfs-install/binutils.sha512` ]; then
      echo -e "${warning}Warning: the SHA-512 checksum of binutils-2.42.tar.xz does not match the trusted one."
      echo    "This means that the package was updated recently, or the repository was attacked."
      echo -e "The tarball 'binutils-2.42.tar.xz' might have malicious content inside.${default}"
      binutils_invalid_func() {
        read -p "Proceed anyway? (y,N):" binutils_invalid
        if [[ -z "$binutils_invalid" ]]; then
          $binutils_invalid=n
        fi
        case $binutils_invalid in
          [Yy])
            echo -e "${warning}Building unsafe Binutils.${default}"
          ;;
          [Nn])
            exit 1
          ;;
          *)
            binutils_invalid_func
        esac
      }
      binutils_invalid_func
    fi
    mkdir -pv ${binutils_dir}/binutils-2.42
    tar -xvf binutils-2.42.tar.xz ${binutils_dir}/binutils-2.42
    mkdir -pv ${binutils_dir}/build
    ${binutils_dir}/binutils-2.42/configure --prefix=${savelocation}/tools     \
                                            --with-sysroot=$savelocation       \
                                            --target=$(uname -m)-lfs-linux-gnu \
                                            --disable-nls                      \
                                            --enable-gprofng=no                \
                                            --disable-werror
    make -C ${binutils_dir}/binutils-2.42/
    make -C ${binutils_dir}/binutils-2.42/ install
  ;;
  *)
    save-error "save_cross_binutils"
esac