#! /bin/bash
# lfs-install - initialization plus formatting the internal storage
# Copyright (C) 2023 Beloglazov Mark <justaguy3331@gmail.com>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>.
set -e
# Color codes for texts
success="\e[0;96m" # High intensity cyan
warning="\e[0;93m" # High intensity yellow
error="\e[0;91m"    # High intensity red
info="\e[0;97m"    # High intensity white
default="\e[0m"    # White unless you modify the default shell color

# Read the arguments for lfs-install
args=$(getopt -a --options d:fhks:l --long "debug:,full-save,help,keep-going,save-file:,license" -- "$@")
if [ $? -ne 0 ]; then
  echo "Use '-h' or '--help' for usage."
  exit 1
fi
eval set -- "$args"

while true; do
  case "$1" in
# -d <var> --debug <var>
# a - print everything
# b - only print current stage of installation
# v - print which scripts and Makefile recipes were invoked and when they exited
# j - print which sub-commands were invoked and when they exited
# p - print which directories were invoked
# n - print no debugging information
  -d|--debug)
    opt_debug="$2"
    shift 2;;
# -f --full-save
  -f|--full-save)
    opt_full_save="1"
    shift 1;;

# -h --help
  -h|--help)
    echo "Usage:"
    echo " lfs-install [-d <opt_debug>] [-h] [-i] [-k] [-s <filename>] [-l]"
    echo ""
    echo "Install Linux From Scratch to a desired drive."
    echo ""
    echo "Options:"
    echo " -d, --debug <opt_debug>    filter debug messages by a desired level"
    echo " -f, --full-save            store all save variables in a savefile"
    echo " -h, --help                 display this help and exit"
    echo " -k, --keep-going           keep going if any error happens, very dangerous option"
    echo " -s, --save-file <filename> define a filename or path to save file, or start with a new save file"
    echo " -l, --license              show script license"
    echo ""
    echo "The 'opt_debug' argument can be 'a' (all), 'b' (currently active stage, see save variables for names),"
    echo "'j' (print which sub-commands are currently invoked),"
    echo "'p' (print which directory is currently invoked),"
    echo "'n' (print no debugging information)."
    echo ""
    echo "The 'filename' argument can be a path to existing savefile, or a path to a new one."
    echo "lfs-install will prompt user for creating new file (recursively) if it doesn't exist"
    echo "while also informing of nonexistent directories."
    exit 0;;

# -k --keep-going
  -k|--keep-going)
    set +e
    shift 1;;

# -s <var> --save-file <var>
# Note that this works only if your internal storage is complete.
# If not, the script will store the var and wait.
  -s|--save-file)
    opt_save_file="$2"
    shift 2;;

# -l --license
  -l|--license)
    echo -e "${info}Please note that you can always exit by pressing 'q'.${default}"
    read -p "Press enter to continue."
    less /usr/local/share/doc/lfs-install/LICENSE
    exit 0;;
  --)
    break;;
  esac
done

echo "run.sh Copyright (C) 2023 Beloglazov Mark <justaguy3331@gmail.com>

This program comes with ABSOLUTELY NO WARRANTY;
for details use '-l' or '--license' options.
This is free software, and you are welcome to redistribute it
under certain conditions; use '-l' or '--license' options for details.
"

# Simple error function to reduce code size
error() {
  echo "${error}Error:" $1
  exit 1
}

# Error that is related to a corrupted save file
save-error() {
  echo -e "${error}Error: this save file is corrupted"
  echo -e "(\$$1 is equal to neither 1 or 0).${default}"
  echo -e "${info}You might want to edit the save file using 'nano'"
  echo -e "(the full location of the save file is $opt_save_file)."
  echo -e "Please note that "1" means the stage is done, and "0" means the stage is not done.${default}"
  exit 1
}

# Load save file if it exists
if [ -f $opt_save_file ]; then
  # workaround for error highlighting
  echo -e "${error}`source $opt_save_file                     || true`${default}"
  fullsavename=$opt_save_file
  echo -e "${error}`mount ${savedevice}2 $savelocation        || true`${default}"
  echo -e "${error}`mount ${savedevice}3 ${savelocation}/boot || true`${default}"
else
  if [[ ! -z $opt_save_file ]]; then
    echo -e "${warning}Save file not found, storing the path to possibly create it later.${default}"
  fi
fi

# Check whether the script is being run with sudo privileges
sudocheck=$(whoami)
if [[ -z "$sudocheck" ]]; then
  error "The result of `whoami` is empty. Perhaps your are running in chroot?${default}"
fi
case $sudocheck in
  root)
    echo -e"${success}Running as sudo (root).${default}"
  ;;
  *)
    error "You must be running this script with sudo (root) privileges.${default}"
  ;;
esac

# Save_partitions stage
if [[ -z "$save_partitions" ]]; then
  save_partitions=0
fi
case $save_partitions in
  1)
  ;;
  0)
    echo "Choose a device to format:"
    lsblk -d
    choose-device() {
      read -p "Enter in the name of the device you've chosen:" devdisk
      if [[ -z "`lsblk -d | grep $devdisk`" ]]; then
        echo -e "${warning}Please enter a valid device name.${default}"
        choose-device
      fi
    }
    choose-device
    # Defining variables for the next actions
    # 'export' just in case, see line 339 (out of this 'case' scope)
    export parteddevice="/dev/$devdisk"
    if [[ ! -z "`mount | grep $parteddevice`"]]; then
      echo -e "${warning}Warning: this device has one or more mountpoints.${default}"
      umountbusydevice-func() {
        read -p "Would you like to unmount all the partitions of the device? (Y/n)" umountbusydevice
        case $umountbusydevice in
          [Yy])
            umount ${parteddevice}?*
          ;;
          [Nn])
            exit 1
          ;;
          *)
            umountbusydevice-func
        esac
      }
      umountbusydevice-func
    fi
    partedsize=`parted --script $parteddevice unit MiB print | grep Disk | awk '{print $3}'`
    partedsize=${partedsize::-3}
    partedlfs=`echo "scale=100; $partedsize - 500" | bc -l`
    # Partitioning the internal storage
    # https://wiki.archlinux.org/title/Partitioning
    if [ -d /sys/firmware/efi ]; then
      echo -e "${info}It appears that your machine has UEFI."
      echo    "It is usually used with GPT partition table, however,"
      echo    "there is an older firmware called BIOS, which instead supports only MBR."
      echo    "UEFI can use that partition table for backwards compatibility,"
      echo -e "but this is recommended to pick only if you need support for BIOS machines.${default}"
      partitiontable-func() {
        read -p "Would you like to use MBR partition table? (y/N)" partitiontable
        case $partitiontable in
          [Yy])
            parted --script $parteddevice mktable mbr
          ;;
          [Nn])
            echo -e "${info}Using GPT partition table.${default}"
            parted --script $parteddevice mktable gpt
          ;;
          *)
            partitiontable-func
        esac
      }
      partitiontable-func
    fi
    parted --script $parteddevice mkpart lfs-swap linux-swap 1MiB 512MiB
    parted --script $parteddevice mkpart lfs ext4 512MiB ${partedlfs}MiB
    parted --script $parteddevice mkpart lfs-efi fat32 ${partedlfs}MiB 100%
    # Formatting the partitions
    # https://wiki.archlinux.org/title/Installation_guide#Format_the_partitions
    mkswap --verbose ${parteddevice}1
    mkfs.ext4 -v ${parteddevice}2
    mkfs.fat -v -F 32 ${parteddevice}3
    if [ ! -z $opt_save_file]; then
      if [ -f $opt_save_file ]; then
        echo "save_partitions=1" >> $opt_save_file
      fi
    fi
  ;;
  *)
    save-error "save_partitions"
esac
# Save_created stage
if [[ -z "$save_created" ]]; then
  save_created=0
fi
# For improving readability
choose-directory() {
  echo "Choose a directory to mount $parteddevice to."
  echo -e "${info}Note: if you pick a directory with contents,"
  read -p "'umount ${parteddevice}2' to access them after exiting the script! (/mnt by default):" savelocation
  if [[ -z "$savelocation" ]]; then
    savelocation=/mnt
  fi
}
# I regret having to write something that big in an if statement
if [ ! -f $opt_save_file ]; then
  savelocation=`dirname $opt_save_file`
  savefilename=`basename $opt_save_file`
  if [[ ! -d "$savelocation" ]]; then
    save-argument-invalid() {
      echo -e "${warning}The path you passed in argument does not exist.${default}"
      read -p "Would you like to create it? [yes, no, retry] (y/n/R):" createpath
      if [[ -z "$createpath" ]]; then
        choose-directory
      fi
      case $createpath in
        [Yy])
          mkdir $savelocation
        ;;
        [Nn])
          exitorcontinue-func(){
            read -p "Would you like to exit now or continue running (the script will start over upon next run!) (Y/n)?" exitorcontinue
            if [[ -z "$exitorcontinue" ]]; then
              exit 1
            fi
            case $exitorcontinue in
              [Yy])
                exit 1
              ;;
              [Nn])
                echo "Continue running..."
              ;;
              *)
                exitorcontinue-func
            esac
          }
          exitorcontinue-func
        ;;
        [Rr])
          choose-directory
        ;;
        *)
          save-argument-invalid
      esac
    }
    save-argument-invalid
  fi
  fullsavename=${savelocation}/${savefilename}.sh
  touch $fullsavename
  echo "save_partitions=1\nsave_created=1\n" > $fullsavename
  awk -i inplace '!seen[$0]++' $fullsavename
  sed -i /save_partitions=0/d $fullsavename
  sed -i /save_created=0/d $fullsavename
fi

case $save_created in
  1)
  ;;
  0)
    choose-directory
    if [[ ! -d "$savelocation" ]]; then
      save-path-invalid() {
        echo -e "${warning}The path you entered in does not exist.${default}"
        read -p "Would you like to create it? [yes, no, retry] (y/n/R):" createpath
        if [[ -z "$createpath" ]]; then
          choose-directory
        fi
        case $createpath in
          [Yy])
            mkdir $savelocation
          ;;
          [Nn])
            exitorcontinue-func() {
              read -p "Would you like to exit now or continue running (the script will start over upon next run!) (Y/n)?" exitorcontinue
              if [[ -z "$exitorcontinue" ]]; then
                exit 1
              fi
              case $exitorcontinue in
                [Yy])
                  exit 1
                ;;
                [Nn])
                  echo "Continue running..."
                ;;
                *)
                  exitorcontinue-func
              esac
            }
            exitorcontinue-func
          ;;
        esac
      }
      save-path-invalid
    fi
    mount ${parteddevice}2 $savelocation
    read -p "Pick a name for the save file ('lfs-save' by default):" savefilename
    if [[ -z "$savefilename" ]]; then
      savefilename=lfs-save
    fi
    if [[ -z "$fullsavename" ]]; then
      fullsavename=${savelocation}/${savefilename}.sh
      touch $fullsavename
    fi
    echo -e "savedevice=$parteddevice\nsavelocation=$savelocation\nsave_partitions=1\nsave_created=1\n" > $fullsavename
    awk -i inplace '!seen[$0]++' $fullsavename
    sed -i /save_partitions=0/d $fullsavename
    sed -i /save_created=0/d $fullsavename
    echo -e "${success}Save file successfully created.${default}"
  ;;
  *)
    save-error "save_created"
esac